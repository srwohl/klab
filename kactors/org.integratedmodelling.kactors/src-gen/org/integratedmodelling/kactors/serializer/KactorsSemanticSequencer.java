/*
 * generated by Xtext 2.19.0
 */
package org.integratedmodelling.kactors.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.integratedmodelling.kactors.kactors.Actions;
import org.integratedmodelling.kactors.kactors.Annotation;
import org.integratedmodelling.kactors.kactors.ArgumentDeclaration;
import org.integratedmodelling.kactors.kactors.Body;
import org.integratedmodelling.kactors.kactors.Classifier;
import org.integratedmodelling.kactors.kactors.Currency;
import org.integratedmodelling.kactors.kactors.Date;
import org.integratedmodelling.kactors.kactors.Definition;
import org.integratedmodelling.kactors.kactors.DoStatement;
import org.integratedmodelling.kactors.kactors.ForStatement;
import org.integratedmodelling.kactors.kactors.Group;
import org.integratedmodelling.kactors.kactors.HeaderRow;
import org.integratedmodelling.kactors.kactors.IfStatement;
import org.integratedmodelling.kactors.kactors.KactorsPackage;
import org.integratedmodelling.kactors.kactors.KeyValuePair;
import org.integratedmodelling.kactors.kactors.List;
import org.integratedmodelling.kactors.kactors.Literal;
import org.integratedmodelling.kactors.kactors.LookupTable;
import org.integratedmodelling.kactors.kactors.Map;
import org.integratedmodelling.kactors.kactors.MapEntry;
import org.integratedmodelling.kactors.kactors.Match;
import org.integratedmodelling.kactors.kactors.MessageCall;
import org.integratedmodelling.kactors.kactors.Model;
import org.integratedmodelling.kactors.kactors.ParameterList;
import org.integratedmodelling.kactors.kactors.Preamble;
import org.integratedmodelling.kactors.kactors.Quantity;
import org.integratedmodelling.kactors.kactors.REL_OPERATOR;
import org.integratedmodelling.kactors.kactors.Statement;
import org.integratedmodelling.kactors.kactors.StatementBody;
import org.integratedmodelling.kactors.kactors.StatementList;
import org.integratedmodelling.kactors.kactors.Table;
import org.integratedmodelling.kactors.kactors.TableClassifier;
import org.integratedmodelling.kactors.kactors.TableRow;
import org.integratedmodelling.kactors.kactors.Unit;
import org.integratedmodelling.kactors.kactors.UnitElement;
import org.integratedmodelling.kactors.kactors.Value;
import org.integratedmodelling.kactors.kactors.WhileStatement;
import org.integratedmodelling.kactors.services.KactorsGrammarAccess;

@SuppressWarnings("all")
public class KactorsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KactorsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KactorsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KactorsPackage.ACTIONS:
				sequence_Actions(context, (Actions) semanticObject); 
				return; 
			case KactorsPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case KactorsPackage.ARGUMENT_DECLARATION:
				sequence_ArgumentDeclaration(context, (ArgumentDeclaration) semanticObject); 
				return; 
			case KactorsPackage.BODY:
				sequence_MessageBody(context, (Body) semanticObject); 
				return; 
			case KactorsPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case KactorsPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case KactorsPackage.DATE:
				sequence_Date(context, (Date) semanticObject); 
				return; 
			case KactorsPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case KactorsPackage.DO_STATEMENT:
				sequence_DoStatement(context, (DoStatement) semanticObject); 
				return; 
			case KactorsPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case KactorsPackage.GROUP:
				if (rule == grammarAccess.getMessageCallRule()) {
					sequence_MessageCall_StatementGroup(context, (Group) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementGroupRule()) {
					sequence_StatementGroup(context, (Group) semanticObject); 
					return; 
				}
				else break;
			case KactorsPackage.HEADER_ROW:
				sequence_HeaderRow(context, (HeaderRow) semanticObject); 
				return; 
			case KactorsPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case KactorsPackage.KEY_VALUE_PAIR:
				sequence_KeyValuePair(context, (KeyValuePair) semanticObject); 
				return; 
			case KactorsPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case KactorsPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case KactorsPackage.LOOKUP_TABLE:
				sequence_LookupTable(context, (LookupTable) semanticObject); 
				return; 
			case KactorsPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case KactorsPackage.MAP_ENTRY:
				sequence_MapEntry(context, (MapEntry) semanticObject); 
				return; 
			case KactorsPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case KactorsPackage.MESSAGE_CALL:
				sequence_MessageCall(context, (MessageCall) semanticObject); 
				return; 
			case KactorsPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case KactorsPackage.NUMBER:
				sequence_Number(context, (org.integratedmodelling.kactors.kactors.Number) semanticObject); 
				return; 
			case KactorsPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case KactorsPackage.PREAMBLE:
				sequence_Preamble(context, (Preamble) semanticObject); 
				return; 
			case KactorsPackage.QUANTITY:
				sequence_Quantity(context, (Quantity) semanticObject); 
				return; 
			case KactorsPackage.REL_OPERATOR:
				sequence_REL_OPERATOR(context, (REL_OPERATOR) semanticObject); 
				return; 
			case KactorsPackage.STATEMENT:
				if (rule == grammarAccess.getNextStatementRule()) {
					sequence_NextStatement(context, (Statement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStatementRule()) {
					sequence_Statement(context, (Statement) semanticObject); 
					return; 
				}
				else break;
			case KactorsPackage.STATEMENT_BODY:
				sequence_StatementBody(context, (StatementBody) semanticObject); 
				return; 
			case KactorsPackage.STATEMENT_LIST:
				sequence_StatementList(context, (StatementList) semanticObject); 
				return; 
			case KactorsPackage.TABLE:
				sequence_Table(context, (Table) semanticObject); 
				return; 
			case KactorsPackage.TABLE_CLASSIFIER:
				sequence_TableClassifier(context, (TableClassifier) semanticObject); 
				return; 
			case KactorsPackage.TABLE_ROW:
				sequence_TableRow(context, (TableRow) semanticObject); 
				return; 
			case KactorsPackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case KactorsPackage.UNIT_ELEMENT:
				sequence_UnitElement(context, (UnitElement) semanticObject); 
				return; 
			case KactorsPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case KactorsPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Actions returns Actions
	 *
	 * Constraint:
	 *     (match=Match | (matches+=Match matches+=Match*) | statement=Statement | statements=StatementList)
	 */
	protected void sequence_Actions(ISerializationContext context, Actions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     (name=ANNOTATION_ID parameters=ParameterList?)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArgumentDeclaration returns ArgumentDeclaration
	 *
	 * Constraint:
	 *     (ids+=LOWERCASE_ID ids+=LOWERCASE_ID*)?
	 */
	protected void sequence_ArgumentDeclaration(ISerializationContext context, ArgumentDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         num=Number | 
	 *         set=List | 
	 *         string=STRING | 
	 *         observable=OBSERVABLE | 
	 *         id=LOWERCASE_ID | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         nodata='unknown' | 
	 *         star?='*'
	 *     )
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     (id=UPPERCASE_ID year=INT units+=UnitElement*)
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Date returns Date
	 *
	 * Constraint:
	 *     (year=INT bc?='BC'? month=INT day=INT (hour=INT min=INT (sec=INT ms=INT?)?)?)
	 */
	protected void sequence_Date(ISerializationContext context, Date semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (annotations+=Annotation* name=LOWERCASE_ID arguments=ArgumentDeclaration? body=MessageBody)
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DoStatement returns DoStatement
	 *
	 * Constraint:
	 *     (body=StatementBody expression=EXPR)
	 */
	protected void sequence_DoStatement(ISerializationContext context, DoStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.DO_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.DO_STATEMENT__BODY));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.DO_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.DO_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoStatementAccess().getBodyStatementBodyParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoStatementAccess().getExpressionEXPRTerminalRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (id=LOWERCASE_ID? value=Value body=StatementBody)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HeaderRow returns HeaderRow
	 *
	 * Constraint:
	 *     ((elements+=LOWERCASE_ID | elements+=STRING) elements+=LOWERCASE_ID? (elements+=STRING? elements+=LOWERCASE_ID?)*)
	 */
	protected void sequence_HeaderRow(ISerializationContext context, HeaderRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (expression=EXPR body=StatementBody (elseIfExpression+=EXPR elseIfBody+=StatementBody)* elseCall=StatementBody?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValuePair returns KeyValuePair
	 *
	 * Constraint:
	 *     ((name=LOWERCASE_ID interactive?='=?'?)? value=Value)
	 */
	protected void sequence_KeyValuePair(ISerializationContext context, KeyValuePair semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     List returns List
	 *
	 * Constraint:
	 *     contents+=Value*
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     (
	 *         number=Number | 
	 *         (from=Number to=Number) | 
	 *         string=STRING | 
	 *         date=Date | 
	 *         boolean='true' | 
	 *         boolean='false'
	 *     )
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LookupTable returns LookupTable
	 *
	 * Constraint:
	 *     table=Table?
	 */
	protected void sequence_LookupTable(ISerializationContext context, LookupTable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MapEntry returns MapEntry
	 *
	 * Constraint:
	 *     (classifier=Classifier value=Value)
	 */
	protected void sequence_MapEntry(ISerializationContext context, MapEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.MAP_ENTRY__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.MAP_ENTRY__CLASSIFIER));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.MAP_ENTRY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.MAP_ENTRY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapEntryAccess().getClassifierClassifierParserRuleCall_0_0(), semanticObject.getClassifier());
		feeder.accept(grammarAccess.getMapEntryAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (entries+=MapEntry entries+=MapEntry*)?
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (
	 *         (id?=LOWERCASE_ID body=StatementList) | 
	 *         ((boolean='true' | boolean='false') body=StatementList) | 
	 *         (type?=CAMELCASE_ID body=StatementList) | 
	 *         (regexp?=REGEXP body=StatementList) | 
	 *         (observable?=OBSERVABLE body=StatementList) | 
	 *         (literal?=Literal body=StatementList) | 
	 *         (text?=STRING body=StatementList) | 
	 *         (arguments=ArgumentDeclaration body=StatementList) | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'? body=StatementList) | 
	 *         (set=List body=StatementList) | 
	 *         (quantity=Quantity body=StatementList) | 
	 *         (date=Date body=StatementList) | 
	 *         (expr=EXPR body=StatementList) | 
	 *         (nodata='unknown' body=StatementList) | 
	 *         (star?='*' body=StatementList) | 
	 *         (anything?='#' body=StatementList)
	 *     )
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageBody returns Body
	 *
	 * Constraint:
	 *     lists+=StatementList*
	 */
	protected void sequence_MessageBody(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageCall returns MessageCall
	 *
	 * Constraint:
	 *     (name=PathName parameters=ParameterList? actions=Actions?)
	 */
	protected void sequence_MessageCall(ISerializationContext context, MessageCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageCall returns Group
	 *
	 * Constraint:
	 *     (body=MessageBody? actions=Actions?)
	 */
	protected void sequence_MessageCall_StatementGroup(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (preamble=Preamble? definitions+=Definition*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NextStatement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         verb=MessageCall | 
	 *         group=StatementGroup | 
	 *         text=EMBEDDEDTEXT | 
	 *         if=IfStatement | 
	 *         while=WhileStatement | 
	 *         do=DoStatement | 
	 *         for=ForStatement | 
	 *         value=Value
	 *     )
	 */
	protected void sequence_NextStatement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (negative?='-'? real=INT long?='l'? (decimal?='.' decimalPart=INT)? ((exponential?='e' | exponential?='E') expNegative?='-'? exp=INT)?)
	 */
	protected void sequence_Number(ISerializationContext context, org.integratedmodelling.kactors.kactors.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (pairs+=KeyValuePair pairs+=KeyValuePair*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Preamble returns Preamble
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             (
	 *                 app?='app' | 
	 *                 user?='user' | 
	 *                 library?='trait' | 
	 *                 library?='library' | 
	 *                 behavior?='behavior' | 
	 *                 behavior?='behaviour'
	 *             ) 
	 *             name=PathName
	 *         )? 
	 *         (
	 *             (
	 *                 worldview=PathName | 
	 *                 observable=OBSERVABLE | 
	 *                 observables=List | 
	 *                 label=LOWERCASE_ID | 
	 *                 label=ID | 
	 *                 label=STRING | 
	 *                 description=STRING | 
	 *                 permissions=STRING | 
	 *                 authors+=STRING | 
	 *                 version=VersionNumber
	 *             )? 
	 *             (imports+=PathName imports+=PathName*)? 
	 *             (created=Date createcomment=STRING?)? 
	 *             (modified=Date modcomment=STRING?)?
	 *         )+
	 *     )
	 */
	protected void sequence_Preamble(ISerializationContext context, Preamble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Quantity returns Quantity
	 *
	 * Constraint:
	 *     (value=Number over?='/'? (unit=Unit | currency=Currency))
	 */
	protected void sequence_Quantity(ISerializationContext context, Quantity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     REL_OPERATOR returns REL_OPERATOR
	 *
	 * Constraint:
	 *     (
	 *         gt?='>' | 
	 *         lt?='<' | 
	 *         eq?='=' | 
	 *         ne?='!=' | 
	 *         le?='<=' | 
	 *         ge?='>='
	 *     )
	 */
	protected void sequence_REL_OPERATOR(ISerializationContext context, REL_OPERATOR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementBody returns StatementBody
	 *
	 * Constraint:
	 *     (verb=MessageCall | value=Value | group=StatementGroup)
	 */
	protected void sequence_StatementBody(ISerializationContext context, StatementBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementGroup returns Group
	 *
	 * Constraint:
	 *     body=MessageBody?
	 */
	protected void sequence_StatementGroup(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementList returns StatementList
	 *
	 * Constraint:
	 *     (first=Statement next+=NextStatement*)
	 */
	protected void sequence_StatementList(ISerializationContext context, StatementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     (
	 *         verb=MessageCall | 
	 *         group=StatementGroup | 
	 *         text=EMBEDDEDTEXT | 
	 *         if=IfStatement | 
	 *         while=WhileStatement | 
	 *         do=DoStatement | 
	 *         for=ForStatement | 
	 *         value=Value
	 *     )
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableClassifier returns TableClassifier
	 *
	 * Constraint:
	 *     (
	 *         boolean='true' | 
	 *         boolean='false' | 
	 *         num=Number | 
	 *         string=STRING | 
	 *         observable=OBSERVABLE | 
	 *         (op=REL_OPERATOR expression=Number) | 
	 *         (int0=Number leftLimit='inclusive'? int1=Number rightLimit='inclusive'?) | 
	 *         set=List | 
	 *         quantity=Quantity | 
	 *         date=Date | 
	 *         expr=EXPR | 
	 *         nodata='unknown' | 
	 *         star?='*' | 
	 *         anything?='#'
	 *     )
	 */
	protected void sequence_TableClassifier(ISerializationContext context, TableClassifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableRow returns TableRow
	 *
	 * Constraint:
	 *     (elements+=TableClassifier elements+=TableClassifier*)
	 */
	protected void sequence_TableRow(ISerializationContext context, TableRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Table returns Table
	 *
	 * Constraint:
	 *     (headers=HeaderRow? rows+=TableRow rows+=TableRow*)
	 */
	protected void sequence_Table(ISerializationContext context, Table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitElement returns UnitElement
	 *
	 * Constraint:
	 *     (id=CAMELCASE_ID | id=LOWERCASE_ID | id=UPPERCASE_ID | unit=Unit)
	 */
	protected void sequence_UnitElement(ISerializationContext context, UnitElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Unit returns Unit
	 *
	 * Constraint:
	 *     (root=UnitElement? (connectors+=UnitOp units+=UnitElement)*)
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     (
	 *         argvalue=ARGVALUE | 
	 *         literal=Literal | 
	 *         id=PathName | 
	 *         urn=UrnId | 
	 *         list=List | 
	 *         map=Map | 
	 *         observable=OBSERVABLE | 
	 *         expression=EXPR | 
	 *         table=LookupTable
	 *     )
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (expression=EXPR body=StatementBody)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KactorsPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getExpressionEXPRTerminalRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
